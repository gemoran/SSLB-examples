g_boot = matrix(0, nrow = R, ncol = K)
d_new_all = matrix(0, nrow = R, ncol = K)
d_rep_all = matrix(0, nrow = R, ncol = K)
d_boot_all = matrix(0, nrow = R, ncol = K)
d_boot_new_all = matrix(0, nrow = R, ncol = K)
d_obs_all = matrix(0, nrow = R, ncol = K)
for (k in 1:K) {
theta = rnorm(p, sd = sqrt(c))
X = matrix(runif(n * p), nrow = n, ncol = p)
y = X %*% theta + rnorm(n)
tXX = crossprod(X)
tXy = crossprod(X, y)
# posterior mean and variance of theta
V = tXX + 1/c * diag(p)
Vinv = chol2inv(chol(V))
theta_mean = Vinv %*% tXy
for (r in 1:R) {
# draw theta | y_obs
theta_draw = as.vector(rmvnorm(1, mean = theta_mean, sigma = Vinv))
d_obs = mean((y - X %*% theta_draw)^2)
# draw y_rep
y_rep = X %*% theta_draw + rnorm(n)
d_rep = mean((y_rep - X %*% theta_draw)^2)
# draw y from population
X_new = matrix(runif(n * p), nrow = n, ncol = p)
y_new = X_new %*% theta + rnorm(n)
d_new = mean((y_new - X_new %*% theta_draw)^2)
# bootstrap
ind = sample(1:n, n, replace = T)
y_train = y[ind]
X_train = X[ind, ]
ind_test = c(sample(ind, size = round((1-p_boot) * n), replace = T),
sample((1:n)[-unique(ind)], size = round(p_boot * n), replace = T))
y_test = y[ind_test]
X_test = X[ind_test, ]
Vinv_boot = chol2inv(chol(crossprod(X_train) + 1/c * diag(p)))
theta_mean_boot = Vinv_boot %*% crossprod(X_train, y_train)
theta_draw_boot = as.vector(rmvnorm(1, mean = theta_mean_boot, sigma = Vinv_boot))
y_rep_boot = X_train %*% theta_draw_boot + rnorm(n)
d_boot = mean((y_rep_boot - X_train %*% theta_draw_boot)^2)
d_boot_new = mean((y_test - X_test %*% theta_draw_boot)^2)
d_rep_all[r, k] = d_rep
d_new_all[r, k] = d_new
d_obs_all[r, k] = d_obs
d_boot_all[r, k] = d_boot
d_boot_new_all[r, k] = d_boot_new
g_pop_pc[r, k] = d_rep > d_new
g_ppc[r, k] = d_rep > d_obs
g_boot[r, k] = d_boot > d_boot_new
}
}
g_ppc_ave = apply(g_ppc, 2, mean)
g_pop_pc_ave = apply(g_pop_pc, 2, mean)
g_boot_ave = apply(g_boot, 2, mean)
g_dat = data.frame("PPC" = g_ppc_ave, "POP_PC" = g_pop_pc_ave, "POP_PC_Boot" = g_boot_ave)
g_dat = pivot_longer(g_dat, cols = 1:ncol(g_dat))
ggplot(g_dat, aes(x = value)) +
geom_histogram(bins = 20) +
facet_wrap(~ name) +
xlab("p-value")
hist(d_rep_all)
hist(d_new_all)
hist(d_new_all, add = T)
hist(d_rep_all)
hist(d_new_all, add = T)
hist(d_obs_all, add = T)
g_ppc_ave = apply(g_ppc, 2, mean)
g_pop_pc_ave = apply(g_pop_pc, 2, mean)
g_boot_ave = apply(g_boot, 2, mean)
g_dat = data.frame("PPC" = g_ppc_ave, "POP_PC" = g_pop_pc_ave, "POP_PC_Boot" = g_boot_ave)
g_dat = pivot_longer(g_dat, cols = 1:ncol(g_dat))
ggplot(g_dat, aes(x = value)) +
geom_histogram(bins = 20) +
facet_wrap(~ name) +
xlab("p-value")
pdf(file = "img/calibration_plot_n_100_p_50.pdf", width = 6, height = 3)
ggplot(g_dat, aes(x = value)) +
geom_histogram(bins = 20) +
facet_wrap(~ name) +
xlab("p-value")
dev.off()
d_new_melt = melt(d_new_all)
d_rep_melt = melt(d_rep_all)
d_obs_melt = melt(d_obs_all)
d_boot_melt = melt(d_boot_all)
d_boot_new_melt = melt(d_boot_new_all)
g_scatter = data.frame(c = d_new_melt$Var2, d_new = d_new_melt$value, d_rep = d_rep_melt$value,
d_obs = d_obs_melt$value, d_boot = d_boot_melt$value, d_boot_new = d_boot_new_melt$value)
d_new_melt = melt(d_new_all)
d_rep_melt = melt(d_rep_all)
d_obs_melt = melt(d_obs_all)
d_boot_melt = melt(d_boot_all)
d_boot_new_melt = melt(d_boot_new_all)
g_scatter = data.frame(d_new = d_new_melt$value, d_rep = d_rep_melt$value,
d_obs = d_obs_melt$value, d_boot = d_boot_melt$value, d_boot_new = d_boot_new_melt$value)
inds = c(1, 5, 11)
ggplot(g_scatter) +
geom_point(mapping = aes(x = d_obs, y = d_rep)) +
geom_abline(intercept = 0, slope = 1, color = "red") +
facet_wrap(~ c, scale = "free") +
xlab(expression(d(Y, theta))) +
ylab(expression(d(Y[rep], theta)))
ggplot(g_scatter) +
geom_point(mapping = aes(x = d_obs, y = d_rep)) +
geom_abline(intercept = 0, slope = 1, color = "red") +
xlab(expression(d(Y, theta))) +
ylab(expression(d(Y[rep], theta)))
k = 1
g_scatter = data.frame(d_new = d_new_all[,k], d_rep = d_rep_all[,k],
d_obs = d_obs_all[,k], d_boot = d_boot_all[,k], d_boot_new = d_boot_new_all[,k])
ggplot(g_scatter) +
geom_point(mapping = aes(x = d_obs, y = d_rep)) +
geom_abline(intercept = 0, slope = 1, color = "red") +
xlab(expression(d(Y, theta))) +
ylab(expression(d(Y[rep], theta)))
ggplot(g_scatter) +
geom_point(mapping = aes(x = d_new, y = d_rep)) +
geom_abline(intercept = 0, slope = 1, color = "red") +
facet_wrap(~ c, scale = "free") +
xlab(expression(d(Y[new], theta))) +
ylab(expression(d(Y[rep], theta)))
ggplot(g_scatter) +
geom_point(mapping = aes(x = d_new, y = d_rep)) +
geom_abline(intercept = 0, slope = 1, color = "red") +
xlab(expression(d(Y[new], theta))) +
ylab(expression(d(Y[rep], theta)))
ggplot(g_scatter) +
geom_point(mapping = aes(x = d_boot_new, y = d_boot)) +
geom_abline(intercept = 0, slope = 1, color = "red") +
facet_wrap(~ c, scale = "free") +
xlab(expression(d(Y[boot~new], theta))) +
ylab(expression(d(Y[boot], theta)))
ggplot(g_scatter) +
geom_point(mapping = aes(x = d_boot_new, y = d_boot)) +
geom_abline(intercept = 0, slope = 1, color = "red") +
xlab(expression(d(Y[boot~new], theta))) +
ylab(expression(d(Y[boot], theta)))
theta
library(mvtnorm)
library(tidyr)
library(ggplot2)
library(reshape2)
library(dplyr)
n = 50
p = 100
K = 500
R = 500
c = exp(2)
p_boot = 0.632
g_pop_pc = matrix(0, nrow = R, ncol = K)
g_ppc = matrix(0, nrow = R, ncol = K)
g_boot = matrix(0, nrow = R, ncol = K)
d_new_all = matrix(0, nrow = R, ncol = K)
d_rep_all = matrix(0, nrow = R, ncol = K)
d_boot_all = matrix(0, nrow = R, ncol = K)
d_boot_new_all = matrix(0, nrow = R, ncol = K)
d_obs_all = matrix(0, nrow = R, ncol = K)
for (k in 1:K) {
theta = rnorm(p, sd = sqrt(c))
X = matrix(runif(n * p), nrow = n, ncol = p)
y = X %*% theta + rnorm(n)
tXX = crossprod(X)
tXy = crossprod(X, y)
# posterior mean and variance of theta
V = tXX + 1/c * diag(p)
Vinv = chol2inv(chol(V))
theta_mean = Vinv %*% tXy
for (r in 1:R) {
# draw theta | y_obs
theta_draw = as.vector(rmvnorm(1, mean = theta_mean, sigma = Vinv))
d_obs = mean((y - X %*% theta_draw)^2)
# draw y_rep
y_rep = X %*% theta_draw + rnorm(n)
d_rep = mean((y_rep - X %*% theta_draw)^2)
# draw y from population
X_new = matrix(runif(n * p), nrow = n, ncol = p)
y_new = X_new %*% theta + rnorm(n)
d_new = mean((y_new - X_new %*% theta_draw)^2)
# bootstrap
ind = sample(1:n, n, replace = T)
y_train = y[ind]
X_train = X[ind, ]
ind_test = c(sample(ind, size = round((1-p_boot) * n), replace = T),
sample((1:n)[-unique(ind)], size = round(p_boot * n), replace = T))
y_test = y[ind_test]
X_test = X[ind_test, ]
Vinv_boot = chol2inv(chol(crossprod(X_train) + 1/c * diag(p)))
theta_mean_boot = Vinv_boot %*% crossprod(X_train, y_train)
theta_draw_boot = as.vector(rmvnorm(1, mean = theta_mean_boot, sigma = Vinv_boot))
y_rep_boot = X_train %*% theta_draw_boot + rnorm(n)
d_boot = mean((y_rep_boot - X_train %*% theta_draw_boot)^2)
d_boot_new = mean((y_test - X_test %*% theta_draw_boot)^2)
d_rep_all[r, k] = d_rep
d_new_all[r, k] = d_new
d_obs_all[r, k] = d_obs
d_boot_all[r, k] = d_boot
d_boot_new_all[r, k] = d_boot_new
g_pop_pc[r, k] = d_rep > d_new
g_ppc[r, k] = d_rep > d_obs
g_boot[r, k] = d_boot > d_boot_new
}
}
g_ppc_ave = apply(g_ppc, 2, mean)
g_pop_pc_ave = apply(g_pop_pc, 2, mean)
g_boot_ave = apply(g_boot, 2, mean)
g_dat = data.frame("PPC" = g_ppc_ave, "POP_PC" = g_pop_pc_ave, "POP_PC_Boot" = g_boot_ave)
g_dat = pivot_longer(g_dat, cols = 1:ncol(g_dat))
ggplot(g_dat, aes(x = value)) +
geom_histogram(bins = 20) +
facet_wrap(~ name) +
xlab("p-value")
n
p
k = 1
g_hist = data.frame(d_new = d_new_all[,k], d_rep = d_rep_all[,k],
d_obs = d_obs_all[,k], d_boot = d_boot_all[,k], d_boot_new = d_boot_new_all[,k])
ggplot(g_hist) +
geom_histogram(data = dat, mapping = aes(x = d_rep, y = ..density..), fill = "red", alpha = 0.3, bins = 50) +
geom_histogram(data = dat, mapping = aes(x = d_obs, y = ..density..), fill = "blue", alpha = 0.3, bins = 50)  +
theme(axis.title=element_text(size=12), plot.title=element_text(size=12)) +
xlab(expression(d(Y, theta))) +
labs(title = "PPC realized discrepancies")
ggplot(g_hist) +
geom_histogram(mapping = aes(x = d_rep, y = ..density..), fill = "red", alpha = 0.3, bins = 50) +
geom_histogram(mapping = aes(x = d_obs, y = ..density..), fill = "blue", alpha = 0.3, bins = 50)  +
theme(axis.title=element_text(size=12), plot.title=element_text(size=12)) +
xlab(expression(d(Y, theta))) +
labs(title = "PPC realized discrepancies")
ggplot(g_hist) +
geom_histogram(mapping = aes(x = d_rep, y = ..density..), fill = "red", alpha = 0.3, bins = 50) +
geom_histogram(mapping = aes(x = d_new, y = ..density..), fill = "blue", alpha = 0.3, bins = 50)  +
theme(axis.title=element_text(size=12), plot.title=element_text(size=12)) +
xlab(expression(d(Y, theta))) +
labs(title = "POP-PC realized discrepancies")
ggplot(g_hist) +
geom_histogram(mapping = aes(x = d_boot, y = ..density..), fill = "red", alpha = 0.3, bins = 50) +
geom_histogram(mapping = aes(x = d_boot_new, y = ..density..), fill = "blue", alpha = 0.3, bins = 50)  +
theme(axis.title=element_text(size=12), plot.title=element_text(size=12)) +
xlab(expression(d(Y, theta))) +
labs(title = "POP-PC bootstrap realized discrepancies")
ggplot(g_hist) +
geom_histogram(mapping = aes(x = d_rep, y = ..density..), fill = "red", alpha = 0.3, bins = 50) +
geom_histogram(mapping = aes(x = d_obs, y = ..density..), fill = "blue", alpha = 0.3, bins = 50)  +
theme(axis.title=element_text(size=12), plot.title=element_text(size=12)) +
xlab(expression(d(Y, theta))) +
labs(title = "PPC realized discrepancies")
c
par(pch = 16)
plot(theta)
points(theta_draw, col = "red")
points(theta_mean, col = "red")
plot(theta)
points(theta_mean, col = "red")
c
theta = c(rep(5, 5), rep(0, p - 5))
sd(theta)
1/c
c = exp(-2)
1/c
library(mvtnorm)
library(tidyr)
library(ggplot2)
library(reshape2)
library(dplyr)
n = 50
p = 100
K = 500
R = 500
c = exp(-2)
p_boot = 0.632
g_pop_pc = matrix(0, nrow = R, ncol = K)
g_ppc = matrix(0, nrow = R, ncol = K)
g_boot = matrix(0, nrow = R, ncol = K)
d_new_all = matrix(0, nrow = R, ncol = K)
d_rep_all = matrix(0, nrow = R, ncol = K)
d_boot_all = matrix(0, nrow = R, ncol = K)
d_boot_new_all = matrix(0, nrow = R, ncol = K)
d_obs_all = matrix(0, nrow = R, ncol = K)
for (k in 1:K) {
theta = c(rep(5, 5), rep(0, p - 5))
X = matrix(runif(n * p), nrow = n, ncol = p)
y = X %*% theta + rnorm(n)
tXX = crossprod(X)
tXy = crossprod(X, y)
# posterior mean and variance of theta
V = tXX + 1/c * diag(p)
Vinv = chol2inv(chol(V))
theta_mean = Vinv %*% tXy
for (r in 1:R) {
# draw theta | y_obs
theta_draw = as.vector(rmvnorm(1, mean = theta_mean, sigma = Vinv))
d_obs = mean((y - X %*% theta_draw)^2)
# draw y_rep
y_rep = X %*% theta_draw + rnorm(n)
d_rep = mean((y_rep - X %*% theta_draw)^2)
# draw y from population
X_new = matrix(runif(n * p), nrow = n, ncol = p)
y_new = X_new %*% theta + rnorm(n)
d_new = mean((y_new - X_new %*% theta_draw)^2)
# bootstrap
ind = sample(1:n, n, replace = T)
y_train = y[ind]
X_train = X[ind, ]
ind_test = c(sample(ind, size = round((1-p_boot) * n), replace = T),
sample((1:n)[-unique(ind)], size = round(p_boot * n), replace = T))
y_test = y[ind_test]
X_test = X[ind_test, ]
Vinv_boot = chol2inv(chol(crossprod(X_train) + 1/c * diag(p)))
theta_mean_boot = Vinv_boot %*% crossprod(X_train, y_train)
theta_draw_boot = as.vector(rmvnorm(1, mean = theta_mean_boot, sigma = Vinv_boot))
y_rep_boot = X_train %*% theta_draw_boot + rnorm(n)
d_boot = mean((y_rep_boot - X_train %*% theta_draw_boot)^2)
d_boot_new = mean((y_test - X_test %*% theta_draw_boot)^2)
d_rep_all[r, k] = d_rep
d_new_all[r, k] = d_new
d_obs_all[r, k] = d_obs
d_boot_all[r, k] = d_boot
d_boot_new_all[r, k] = d_boot_new
g_pop_pc[r, k] = d_rep > d_new
g_ppc[r, k] = d_rep > d_obs
g_boot[r, k] = d_boot > d_boot_new
}
}
g_ppc_ave = apply(g_ppc, 2, mean)
g_pop_pc_ave = apply(g_pop_pc, 2, mean)
g_boot_ave = apply(g_boot, 2, mean)
g_dat = data.frame("PPC" = g_ppc_ave, "POP_PC" = g_pop_pc_ave, "POP_PC_Boot" = g_boot_ave)
g_dat = pivot_longer(g_dat, cols = 1:ncol(g_dat))
ggplot(g_dat, aes(x = value)) +
geom_histogram(bins = 20) +
facet_wrap(~ name) +
xlab("p-value")
library(mvtnorm)
library(tidyr)
library(ggplot2)
library(reshape2)
library(dplyr)
n = 50
p = 100
K = 500
R = 500
c = exp(2)
p_boot = 0.632
g_pop_pc = matrix(0, nrow = R, ncol = K)
g_ppc = matrix(0, nrow = R, ncol = K)
g_boot = matrix(0, nrow = R, ncol = K)
d_new_all = matrix(0, nrow = R, ncol = K)
d_rep_all = matrix(0, nrow = R, ncol = K)
d_boot_all = matrix(0, nrow = R, ncol = K)
d_boot_new_all = matrix(0, nrow = R, ncol = K)
d_obs_all = matrix(0, nrow = R, ncol = K)
for (k in 1:K) {
theta = rnorm(p, sd = sqrt(c))
X = matrix(runif(n * p), nrow = n, ncol = p)
y = X %*% theta + rnorm(n)
tXX = crossprod(X)
tXy = crossprod(X, y)
# posterior mean and variance of theta
V = tXX + 1/c * diag(p)
Vinv = chol2inv(chol(V))
theta_mean = Vinv %*% tXy
for (r in 1:R) {
# draw theta | y_obs
theta_draw = as.vector(rmvnorm(1, mean = theta_mean, sigma = Vinv))
d_obs = mean((y - X %*% theta_draw)^2)
# draw y_rep
y_rep = X %*% theta_draw + rnorm(n)
d_rep = mean((y_rep - X %*% theta_draw)^2)
# draw y from population
X_new = matrix(runif(n * p), nrow = n, ncol = p)
y_new = X_new %*% theta + rnorm(n)
d_new = mean((y_new - X_new %*% theta_draw)^2)
# bootstrap
ind = sample(1:n, n, replace = T)
y_train = y[ind]
X_train = X[ind, ]
ind_test = c(sample(ind, size = round((1-p_boot) * n), replace = T),
sample((1:n)[-unique(ind)], size = round(p_boot * n), replace = T))
y_test = y[ind_test]
X_test = X[ind_test, ]
Vinv_boot = chol2inv(chol(crossprod(X_train) + 1/c * diag(p)))
theta_mean_boot = Vinv_boot %*% crossprod(X_train, y_train)
theta_draw_boot = as.vector(rmvnorm(1, mean = theta_mean_boot, sigma = Vinv_boot))
y_rep_boot = X_train %*% theta_draw_boot + rnorm(n)
d_boot = mean((y_rep_boot - X_train %*% theta_draw_boot)^2)
d_boot_new = mean((y_test - X_test %*% theta_draw_boot)^2)
d_rep_all[r, k] = d_rep
d_new_all[r, k] = d_new
d_obs_all[r, k] = d_obs
d_boot_all[r, k] = d_boot
d_boot_new_all[r, k] = d_boot_new
g_pop_pc[r, k] = d_rep > d_new
g_ppc[r, k] = d_rep > d_obs
g_boot[r, k] = d_boot > d_boot_new
}
}
g_ppc_ave = apply(g_ppc, 2, mean)
g_pop_pc_ave = apply(g_pop_pc, 2, mean)
g_boot_ave = apply(g_boot, 2, mean)
g_dat = data.frame("PPC" = g_ppc_ave, "POP_PC" = g_pop_pc_ave, "POP_PC_Boot" = g_boot_ave)
g_dat = pivot_longer(g_dat, cols = 1:ncol(g_dat))
ggplot(g_dat, aes(x = value)) +
geom_histogram(bins = 20) +
facet_wrap(~ name) +
xlab("p-value")
n
p
theta
plot(theta, pch = 16)
points(theta_mean, pch = 16, col = "red")
sqrt(0.5)
# R script for Simulation 1 of SSLB paper
library(fabia)
library(SSLB)
library(mvtnorm)
library(isa2)
library(biclust)
# Requires these functions
source("../SSLB_functions.R")
# directory for C code for BicMix (downloaded from https://www.cs.princeton.edu/~bee/software/BicMix-Code-for-distribution.zip)
# CHANGE TO CORRECT DIRECTORY
bicmix_dir <- "../../Code/BicMix/BicMix"
GEN_DATA <- F # if true, generate new data. if false, read in data
RUN_SSLB <- T
RUN_BICMIX <- T
RUN_FABIA <- T
READ_SSBiEM = T
RUN_ISA = F
RUN_SPECTRAL = F
RUN_PLAID = F
set.seed(123456789)
N <- 300 # number of samples
G <- 1000 # number of features
K <- 15 # number of biclusters
K_init <- 30 # number of initial biclusters
nrep <- 50 # number of replications
#-----------------------------------
methods <- c("SSLB_IBP", "SSLB_PY", "SSLB_BB", "Bicmix", "FABIA", "SSBiEM",
"ISA", "Spectral", "Plaid")
metrics <- c("consensus", "recovery", "relevance", "var", "K")
n_methods <- length(methods)
n_metrics <- length(metrics)
result <- array(NA, dim = c(n_methods, n_metrics, nrep))
rownames(result) <- methods
colnames(result) <- metrics
r=1
dir <- paste("data/rep", r, sep = "")
# generate data
if (GEN_DATA) {
get_data <- generate_sparse_bic(n_f = N, n_l = G, n_bic = K, min_f = 5, max_f = 20,
min_l = 10, max_l = 50, overlap_f = 5, overlap_l = 15,
mean_f = 2, sd_f = 1, mean_l = 3, sd_l = 1,
sd_f_noise = 0.2, sd_l_noise = 0.2, sd_epsilon = 1)
Y <- get_data$data
X <- get_data$factors_bic
B <- get_data$loadings_bic
write.table(t(Y), file = paste(dir, "/Y.txt", sep = ""), row.names = FALSE, col.names = FALSE)
write.table(X, file = paste(dir, "/X.txt", sep = ""), row.names = FALSE, col.names = FALSE)
write.table(B, file = paste(dir, "/B.txt", sep = ""), row.names = FALSE, col.names = FALSE)
} else {
Y <- as.matrix(read.table(file = paste(dir, "/Y.txt", sep = "")))
Y <- t(Y)
X <- as.matrix(read.table(file = paste(dir, "/X.txt", sep = "")))
B <- as.matrix(read.table(file = paste(dir, "/B.txt", sep = "")))
}
setwd("~/Dropbox/phd/research/Biclustering/Examples/supplementary_code/sim_study_1")
dir <- paste("data/rep", r, sep = "")
# generate data
if (GEN_DATA) {
get_data <- generate_sparse_bic(n_f = N, n_l = G, n_bic = K, min_f = 5, max_f = 20,
min_l = 10, max_l = 50, overlap_f = 5, overlap_l = 15,
mean_f = 2, sd_f = 1, mean_l = 3, sd_l = 1,
sd_f_noise = 0.2, sd_l_noise = 0.2, sd_epsilon = 1)
Y <- get_data$data
X <- get_data$factors_bic
B <- get_data$loadings_bic
write.table(t(Y), file = paste(dir, "/Y.txt", sep = ""), row.names = FALSE, col.names = FALSE)
write.table(X, file = paste(dir, "/X.txt", sep = ""), row.names = FALSE, col.names = FALSE)
write.table(B, file = paste(dir, "/B.txt", sep = ""), row.names = FALSE, col.names = FALSE)
} else {
Y <- as.matrix(read.table(file = paste(dir, "/Y.txt", sep = "")))
Y <- t(Y)
X <- as.matrix(read.table(file = paste(dir, "/X.txt", sep = "")))
B <- as.matrix(read.table(file = paste(dir, "/B.txt", sep = "")))
}
lambda1 <- 1
lambda1_tilde <- 1
lambda0s <- c(1, 5, 10, 50, 100, 500, 1000, 10000, 100000, 1000000, 10000000)
lambda0_tildes <- lambda0s
SSLB_output <- capture.output(out <- SSLB(Y,
K_init,
lambda0s = lambda0s,
lambda0_tildes = lambda0_tildes,
lambda1 = lambda1,
lambda1_tilde = lambda1_tilde,
alpha = 1,
d = 0,
IBP = 1, EPSILON = 0.01))
plot_matrix(out$X)
# Requires these functions
source("../SSLB_functions.R")
# Requires these functions
source("../SSLB_functions.R")
plot_matrix(out$X)
out$K
result_SSLB <- analyze_bic(X_SSLB, B_SSLB, X, B)
X_SSLB <- out$X
B_SSLB <- out$B
K_SSLB <- ncol(B_SSLB)
result_SSLB <- analyze_bic(X_SSLB, B_SSLB, X, B)
result_SSLB$consensus
out$path$lambda0_tildes
